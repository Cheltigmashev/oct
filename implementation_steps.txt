    ПЕРИОДИЧЕСКИ ВЫПОЛНЯЕМЫЕ ДЕЙСТВИЯ
        1. Запуск browser-sync в прокси-режиме поверх локального сервера Django (порт при запуске сервера должен быть 8000), находясь в директории проекта Django. Используется команда: browser-sync start --proxy "localhost:8000" --files "octapp/templates/*/*.html, oct/*.py, octapp/*.py, octapp/static/octapp/css/*.css, octapp/static/octapp/js/*.css, octapp/static/octapp/img/*.css, *.*". При этом перед авторизацией на сайте необходимо отключать автоматический перезапуск браузера в веб-интерфейсе browser-sync в случае изменений отслеживаемых файлов, иначе авторизоваться не удается.
        2. Запуск либо перезапуск локального веб-сервера. Для этого следует активировать виртуальное окружение для проекта, чтобы сделать возможным импортирование приложений django, а затем в директории проекта выполнить в командной строке команду: «python manage.py runserver». Для удобства использовался bat-файл, листинг которого приведен ниже.

        Листинг 0. Содержимое bat-файла для запуска тестового django-сервера
        cd "C:\!FILES\!APF\!ProgrammingAndDevelopment\WEB\OnlineCustomTesting"
        echo Running of test django server
        call octenv\Scripts\activate.bat
        python manage.py runserver

        3. Запуск koala, работающего затем в фоновом режиме и компилирующего .css файл(ы).
        4. На веб-сервере в случае внесения изменений в проект:
            4.1 Сбор статичных файлов командой python manage.py collectstatic;
            4.2 Перезапуск веб-приложения.
        5. Создание миграций БД и их выполнение при добавлении одной либо нескольких новых Django-моделей, а также при при изменении полей существующих моделей и установке Django-приложений. Для этого следует активировать виртуальное окружение проекта и использовать команды «python manage.py makemigrations» — для создания миграций, и «python manage.py migrate» — для их выполнения. Создавать миграции на развернутом сайте не нужно — созданные на локальном компьютере разработчика миграции отправляются на сервер посредством сервиса GitHub, где они и выполняются.
        6. Регистрация новых моделей в административной панели с помощью "admin.site.register(SomeModel)".

ШАГИ ПРОГРАММНОЙ РЕАЛИЗАЦИИ

1. Устанавливаем Visual Studio Code (версия 1.11), python (3.5.2), git, node.js (для утилиты browser-sync), browser-sync, koala (для компиляции файлов формата css из файлов sass).
для VS Code’а устанавливаем следующие плагины: close HTML/XML tab, Django Snippets, Django Template, ESLint, Gist Extension, MagicPython, Python, Python-autopep8, Sass, Sass Lint (после установки этого расширения следует установить сам линтер командой "npm install -g sass-lint"), Sublime Text Keymap.
Расширение Python ориентировано на проверку (линтинг) Python-кода, автозавершение ввода, отладку. Для работы линтинга требуется установка pylint и создание конфигурационного файла командой "pylint --generate-rcfile > .pylintrc" в командной строке Windows. 
Установка browser-sync выполняется командой: "npm install -g browser-sync".
Для веб-браузера Google Chrome устанавливаем расширение «Emmet Re:view» [https://chrome.google.com/webstore/detail/emmet-review/epejoicbhllgiimigokgjdoijnpaphdp], чтобы облегчить адаптацию внешнего вида сайта под разные устройства.

2. Устанавливаем sass из http://sass-lang.com/install или http://koala-app.com

3. Создаем виртуальное окружение в той же папке командой:
«python -m venv octenv»

4. Активируем виртуальное окружение командой:
«octenv\Scripts\activate»

5. Устанавливаем Django (версия 1.10.6 на данный момент) командой:
«pip install django»

6. Создаем Django-проект командой:
«django-admin startproject oct .»

7. Вносим изменения в oct/settings.py.
Добавляем в настройки информацию о расположении статичных файлов. После переменной STATIC_URL добавляем новую - STATIC_ROOT:
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

8. Создаем базу данных для проекта командой:
«python manage.py migrate» (рис. «8Создание БД»)

9. Впервые запускаем локальный веб-сервер командой «python manage.py runserver» (рис. «9Окно командной строки при первом запуске локального веб-сервера»)

10. Проверяем, какую HTML-страницу выдает сервер. (рис. «10Страница по адресу http://127.0.0.1:8000»)

11. Создаем отдельное django-приложение командой:
«python manage.py startapp octapp», используя уже другое окно интерпретатора командной строки, поскольку в прежнем выводятся запросы к серверу.

12. В octapp\static\octapp добавляем файлы bootstrap (css, fonts, js). Стоит отметить, что такая «тавтология» директорий для статичных файлов обусловлена необходимостью создания пространств имен (англоязычный термин — namespacing). Django будет использовать первый найденный статичный файл с подходящим именем, и если есть статичный файл с тем же именем в другом приложении, то Django не сможет провести между ними различие, как отмечается в [https://docs.djangoproject.com/en/dev/howto/static-files/#serving-other-directories]. Для лучшего понимания может быть полезно увидеть, как статичные файлы собираются на сервере команды "python manage.py collectstatic" модуля django.contrib.staticfiles, а именно, какое дерево директорий выстраивается внутри папки для статичных файлов oct\static (рис. 12Структура директории static на веб-сервере). Имя папки для статичных файлов, static, указывается в переменной STATIC_ROOT, находящейся в файле настроек проекта — oct\settings.py.

13. Сообщаем Django, что теперь он должен использовать созданное приложение. Для этого в файле oct\settings.py. Нам нужно найти INSTALLED_APPS и добавить к списку 'octapp', прямо перед ).


14. Создаем пользователя-администратора командой "python manage.py createsuperuser".
имя пользователя: Cheltigmashev
emaiil: danil.cheltigmashev@yandex.ru
пароль: yadanil12345

15. Добавляем файл .gitignore со следующим содерижмым:
*.pyc
__pycache__
octenv
db.sqlite3
.DS_Store

16. Инициализируем git-репозиторий и конфигурируем его с помощью команд:
1) git config core.autocrlf true
Тогда при коммитах (или, если говорить конкретнее, при чтении файлов из файловой системы) все переводы строк при хранении будут приведены к виду \n, как в *nix, а при записи в файлы будут преобразованы к виду \r\n, как в Windows.
2) git config core.safecrlf warn
При таких настройках конфигурации git будет автоматически преобразовывать переводы строк при фиксации изменений (коммитах), но в рабочей директории оставлять у файлов их первоначальные переводы строк. При добавлении файлов в отслеживаемые git будет выдавать предупреждения о преобразовании переводов строк вида "LF will be replaced by CRLF in [какой-либо файл]".

17. Добавляем все файлы (кроме игнорируемых) файлы в отслеживаемые (команда git add --all), делаем первый коммит — фиксацию изменений (git commit -m "initial commit" и назначаем тег версии (git tag v.0.0.1).

18. Создаем на сервисе github.com репозиторий проекта (рисунки 18_1Создание репозитория на github’е, 18_2Страница созданного репозитория).

19. Вносим в git сведения об удаленном репозитории командой:
git remote add origin https://github.com/Cheltigmashev/oct.git
Загружаем локальный репозиторий на удаленный с помощью команды:
git push -u origin master
Теперь на https://github.com/Cheltigmashev/oct находится удаленный репозиторий, идентичный локальному, за исключением игнорируемых файлов и директорий, которые есть в локальном, но которых нет в удаленном репозитории.

20. Разворачиваем систему на веб-сервере. Для этого воспользуемся бесплатным сервисом для публикации веб-проектов PythonAnywhere (https://www.pythonanywhere.com). 
  20.1. Создадим бесплатный аккаунт уровня "Beginner" (рис. 20.1_1Регистрация на www.pythonanywhere.com, 20.1_2Страница с сообщением об успешной регистрации). При выборе имени пользователя учитываем, что это имя станет частью URL нашего сайта.

  20.2. Загружаем код проекта из GitHub на сервер. Для этого на www.pythonanywhere.com запускаем новую консоль bash (это популярная разновидность командной оболочки UNIX) (рис. 20.2_1Консоль bash) и, используя эту консоль, «клонируем» репозиторий командой "git clone https://github.com/Cheltigmashev/oct.git" (рис. 20.2_2Клонирование github-репозитория)

  20.3. Используем команду "tree oct", чтобы проверить структуру папок после «клонирования» (рисурок 20.3Структура папок после клонирования). Чтобы на экране уместилась вся структура без необходимости прокрутки и «склеивания» машстаб страницы был уменьшен до 80%.

  20.4. Создаем виртуальное окружение на PythonAnywhere в папке проекта (oct) с помощью команд: "cd oct" (для перехода в нее) и "virtualenv --python=python3.6 octenv" (для создания виртуального окружения).

  20.5 Активируем виртуальное окружение, устанавливаем Django (версия 1.11) и утилиту для работы со статичными файлами whitenoise (версия 3.3.0) (рис. 20.5Активация виртуального окружения, установка Django и whitenoise) командами "source octenv/bin/activate" и "pip install django whitenoise" соответственно. Статичными файлами называют файлы, которые не содержат программный код, это, например файлы формата HTML или CSS. Работа с подобными файлами на серверах отличается, по сравнению с их работой на тестовом сервере Django.

  20.6 Перемещаемся в директорию oct ("cd oct") и собираем все статичные файлы, необходимые серверу с помощью команды "python manage.py collectstatic" (рис. 20.6Сбор статичных файлов). По мере разработки системы эта команда будет использована периодически и по мере необходимости. На рисунке можно увидеть, что большая часть статичных файлов относится к оформлению страниц (шаблонов) административной панели Django.

  20.7 Поскольку БД была добавлена в игнорируемые git’ом файлы, на веб-сервера она отсутствует, и нам нужно инициализировать ее, а также добавить суперпользователя, с помощью тех же команд, которые уже были использованы для локальной копии проека — это команды «python manage.py migrate» и "python manage.py createsuperuser" (рис. 20.7Создание БД и суперпользователя на веб-сервере).

  20.8 Теперь все готово для публикации системы в качестве веб-приложения. Для этого переходим на вкладку Web (рис. 20.8_1Вкладка Web на www.pythonanywhere.com) и нажимаем "Add a new web app". Нас встречает модальное окно, в котором говорится, что у нас нет возможности выбрать пользовательское доменное имя, поскольку используется аккаунт типа Beginner (рис. 20.8_2Сообщение об отсутствии возможности выбрать пользовательское доменное имя). Нажимаем "Next". Затем нам предлагают либо выбрать Web-фреймворк, использующий язык Python, либо конфигурирование вручную (manual configuration) (рис. 20.8_3Выбор веб-фреймворка настройки вручную). Выбираем manual configuration, а на следующем окне, окне выбора версии языка — выбираем Python версии 3.6. Затем, в следующем модальном окне нам сообщают следующее (перевод с английского):
  «Конфигурирование вручную предполагает редактирование вашего конфигурационного файла WSGI в /var/www/. Как правило это импортирует WSGI-совместимое приложение, которое вы храните где-нибудь в другом месте.
  Когда вы нажмете "Далее", мы создадим для вас WSGI файл, включающий простое приложение "Здравствуй, Мир", которое вы можете использовать, чтобы освоиться (начать работу), а также включающее несколько комментариев того, как пользоваться другими фреймворками. Также вы сможете указать виртуальное окружение, которое будет использоваться для вашего приложения.»

  20.9 На странице с настройками веб-приложения (рис. 20.9_1Страница с настройками веб-приложения), куда нас перенаправили после прочтения сообщения о ручном конфигурировании, необходимо настроить виртуальное окружение. В секции "Virtualenv" нажимаем "Enter the path to a virtualenv" и набираем /home/customtesting/octenv/. В случае успеха операции эта секция настроек будет выглядеть так, как показано на рисунке (рис. 20.9_2Виртуальное окружение задано корректно).

  20.10 Редактируем файл WSGI. В Django используется протокол стандартный протокол для обслуживания веб-сайтов — WSGI, который поддерживается PythonAnywhere. С помощью конфигурационного файла WSGI PythonAnywhere может распознать наш Django-проект. Чтобы внести изменения в уже добавленный при создании веб-приложения WSGI файл, следует кликнуть по ссылке рядом с "WSGI configuration file" в секции "Code" страницы настроек веб-приложения. В нашем случае это ссылка "/var/www/customtesting_pythonanywhere_com_wsgi.py". Эта ссылка перенаправляет на редактор, в котором открыт наш стандартный WSGI файл (рис. 20.10Стандартный WSGI файл в онлайн редакторе). Удаляем стандартый код и вводим тот, который приведен на листинге ниже.

  Листинг 1. Содержимое WSGI-файла
  import os
  import sys

  path = '/home/customtesting/oct' # путь к веб-приложению
  if path not in sys.path:
    sys.path.append(path)

  os.environ['DJANGO_SETTINGS_MODULE'] = 'oct.settings' # имя файла настроек Django

  from django.core.wsgi import get_wsgi_application
  from whitenoise.django import DjangoWhiteNoise
  application = DjangoWhiteNoise(get_wsgi_application())


  После чего сохраняем файл, используя соответствующую кнопку в интерфейсе редактора. Данный файл:
    указывает PythonAnywhere где располагается наше веб-приложение;
    указывает наименование файла настроек Django;
    загружает утилиту «whitenoise» для работы со статичными файлами.

  20.11 Далее перезапускаем наше веб-приложение (зеленая кнопка "reload customtesting.pythonanywhere.com") и проверяем его работу, используя веб-браузер и ссылку на сайт на странице настроек веб-приложения (рис. 20.11Сайт в сети Интернет и информация отладчика Django об ошибке). Видим сообщение об ошибке "Недопустимый хост". Однако, будем считать, что развертываение сайта завершено, поскольку последующие шаги будут относиться уже к дальнейшей работе над системой.
  
21. Чтобы исправить ошибку, необходимо внести изменения в файл oct/settings.py, а именно, добавить в список ALLOWED_HOSTS следующие элементы: '127.0.0.1', 'customtesting.pythonanywhere.com', '127.0.0.1:8000', 'localhost'. Добавление элемента 'localhost' связано с тем, что будет использоваться browser-sync в режиме прокси. Затем делаем коммит, отправляем изменения на удаленный репозиторий (теперь, поскольку мы запускали команду push с параметром -u, можно вводить в окно командной строки вместо "git push -u origin master" просто "git push") и забираем их на pythonanywhere с помощью команды "git pull" (рис. 21_1Загрузка изменений удаленного репозитория на развернутом проекте (сайте)). Там же следует выполнить в терминале команду для сбора статичных файлов на сервере. Проверяя работоспособность развернутой в сети Интерент системы с помощью веб-браузера видим, что ошибка "DisallowedHost" исчезла, а вместо нее отображается стандартное сообщение о том, что Django работает (рис. 21_2Стандартное сообщение Django вида "It works!" (в переводе — оно работает / заработало) на развернутом сайте в сети Интернет).

22. Поскольку 4 апреля 2017 вышла новая, 1.11 версия Django, которая и была установлена на www.pythonanywhere.com, на локальном проекте все еще установлена Django 1.10.6, поэтому обновляем ее с помощью команды "pip install -U django" (рис. 22Обновление Django до версии 1.11).
https://djbook.ru/rel1.6/howto/upgrade-version.html
обновление до последней версии Django имеет ряд преимуществ:
Добавление новой функциональности и различных улучшений
Закрытие старых багов
Наконец, устаревающие версии Django со временем перестают получать обновления безопасности.
Если вы будете обновлять Django при выходе каждого нового релиза, это сделает процедуру последующих обновлений менее болезненной и сохранит ваш код в актуальном состоянии.
https://djbook.ru/rel1.6/howto/upgrade-version.html
Если при запуске обновления работал локальный сервер с Django, то он завершает свою работу.

23. Чтобы теги label стандартных форм Django были на русском языке прописываем в setting.py следующее:
LANGUAGE_CODE = 'ru-RU' # русская локаль
USE_I18N = True # включаем интернационализацию по-умолчанию
Можно также отметить, что это также влияет и на локализацию административной панели. Если до этих действий она была на английском языке (рис. 23_1До изменения кода языка), то после — на русском (рис. 23_2После изменения кода языка).

24. Теперь, прежде чем браться за верстку шаблона главной страницы, его следует связать с каким-либо представлением — view'ом.
Представление в Django - это функция, вызываемая при обращения к конкретному URL и возвращающая необходимые данные [https://djbook.ru/rel1.8/faq/general.html].
В представлении располагается логика работа Django-приложения. Оно извлекает информацию из модели/моделей и передает ее в какой-либо шаблон в виде словаря. Для того, чтобы связать шаблон с представлением, нужно назначить на соответствующий URL (в данном случае это будет адрес самого сайта, т.е. корневой адрес) соответствующее представление, которое может также принимать либо не принимать из конфигурации URL Django (URLconf) переменные. URLconf является набором шаблонов (паттернов) регулярных выражений, которые Django будет сопоставлять с полученным URL, для выбора нужного, правильного представления.
Итак, в файле oct\urls.py уже есть URL для панели администрирования. Добавим новый элемент в этот список urlpatterns — url(r'', include('octapp.urls')), а также импортируем функцию include из django.conf.urls. Теперь Django будет перенаправлять все запросы к 'customtesting.pythonanywhere.com', либо к 'http://127.0.0.1:8000/', либо к 'http://localhost:3000' (в случае использования прокси browser-sync) к octapp.urls для поиска дальнейших инструкций.
Создадим URLconf для нашего приложения octapp — файл octapp\urls.py. В нем мы импортируем url из django.conf.urls и модуль views из текующей папки. В URL-шаблоны добавим url(r'^$', views.tests_lists, name='tests_lists').

Листинг 2. Содержимое файла octapp\urls.py
from django.conf.urls import url
from . import views

urlpatterns = [
    url(r'^$', views.tests_lists, name='tests_lists'),
]

Теперь view с именем tests_lists связан с URL-шаблоном ^$. Это регулярное выражение пустой строке, что нормально, потому что для обработчиков URL в Django адрес 'http://127.0.0.1:8000/' не является частью URL. Этот URL-шаблон указывает Django, что views.tests_lists — это соответствующее представление для запроса к сайту по адресу 'http://127.0.0.1:8000/' в случае локального веб-сервера. В случае сайта, развернутого на www.pythonanywhere.com, это будет адрес 'customtesting.pythonanywhere.com'. Далее, добавим в файл octapp\views.py представление tests_lists в качестве нового метода. Листинг метода приведен ниже.

Листинг 3. Метод (представление) tests_lists
def tests_lists(request):
    return render(request, 'octapp/tests_lists.html', {})

Здесь следует заметить, что путь к шаблону указывается относительно папки templates, находящейся в директории Django-приложения (octapp). Создадим файл шаблона по указанному нами в представлении пути "octapp\templates\octapp\tests_lists.html".

25. Сверстаем шаблон главной страницы, используя при этом локальный сервер Django и программу browser-sync. Для выбора и подключения шрифтов используем google-шрифты, которые можно найти по адресу https://fonts.google.com. Для стилизации шаблона используем препроцессор SASS и одноименный синтаксис. Список тестов пока не будет шаблонизироваться встроенным шаблонизатором Django и извлекаться из БД, а будет статичным, поскольку соответствующие модель и представление не созданы, а прежде чем заниматься фунционалом добавления, просмотра и прохождения тестов, нужно реализовать функционал регистрации, аутентификации и регистрации (рис. 25_1Главная страница со списками тестов в режиме гостя и 25_2Главная страница со списками тестов в режиме администратора).

26. Выделим из шаблона главной страницы со списками тестов (tests_lists.html) базовый шаблон и назовем его base.html. Он будет включать в себя шапку, подвал сайта, подключение стилей и скриптов JavaScript bootstrap’а, а также стили шрифтов Google Fonts. Наследование базового шаблона укажем с помощью строки "{% extends 'octapp/base.html' %}" на первой строке шаблона-потомка. Далее укажем, что содержимое шаблона-потомка будет располагаться в блоке "content" базового шаблона. Для этого используем теги Django-шаблона "{% block content %}" и "{% endblock %}" как в шаблоне-предке, так и в шаблоне потомке. Также должным образом переименуем существующие файлы стилей, вынося свойства, относящиеся к базовому шаблону в файлы стилей с именем base, а прежний файл назовем tests_lists_style. Подразумевается, что делаем это с файлами формата .sass, в то время как css-файлы просто удалим, а после вышеупомянутых операций просто скомпилируем новые. Для подключения файлов стилей в шаблонах-потомках используем блок page_style, т.е. "{% block page_style %}". Здесь следует отметить, что в случае удаления или переименования статичных файлов, уже ненужные статичные файлы могу все еще оставаться на веб-сервере в папке static. В нашем случае это были файлы стилей с именем style.

27. Реализуем функционал регистрации, аутентификации, авторизации и выход из системы (logout) пользователей. Решено использовать приложение django-registration и его англоязычную документацию, которую можно найти по адресу https://django-registration.readthedocs.io/en/2.2/. 
    27.1 Наиболее предпочтительным методом установки данного предложения, как указано в документации, является использование инсталлятора пакетов pip. Вводим в командной строке команду "pip install django-registration", находясь при этом в папке проекта (рис. 27.1 Установка приложения django-registration) при условии предварительной активации виртуального окружения проекта.

    27.2 Необходимо убедиться, что для проекта Django установлен django.contrib.auth. Это можно проверить, обратившись к файлу settings.py и к переменной-списку INSTALLED_APPS, в котором и должен присутствовать элемент django.contrib.auth. Действительно, по умолчанию это приложение уже установлено. При этом добавлять приложение registration (django-registration) в данный список не нужно, поскольку, как говорится в документации, это следует делать только при использовании основанного на модели процесса активации.

    27.3 Настроим URL-шаблоны для приложения. Для одношагового процесса регистрации необходимые шаблоны находятся в registration.backends.simple.urls, поэтому их можно просто включить в корневую URL-конфигурацию проекта, т.е. добавить "url(r'^accounts/', include('registration.backends.simple.urls'))" к существующим URL-шаблонам в файле oct\urls.py. После чего добавим соответствующие URL'ы для ссылок и для атрибута форм action в базовом шаблоне: {% url 'auth_login' %}, {% url 'auth_logout' %}, {% url 'registration_register' %}, {% url 'auth_password_reset' %}. При этом в документации имена этих URL’ов не указаны, но их можно узнать непосредственно из файла urls.py самого приложения, файлы которого располагаются в виртуальном окружении.

    27.4 Далее нужно создать несколько необходимых шаблонов для приложения django-registration, а также необходимых представлениям в django.contrib.auth.
    Добавим в папку шаблонов новую директорию — "registration", и создадим в ней пару шаблонов:
        1. registration/registration_form.html
        Используется, чтобы отображать пользователям форму, которую они будут заполнять при регистрации. По умолчанию в качестве контекста ему передается форма регистрации «RegistrationForm», к которой из шаблона можно обратиться через переменную form [https://django-registration.readthedocs.io/en/2.2/quickstart.html].
        2. registration/login.html 
        Поскольку в нашем случае форма для авторизации находится в шапке главной страницы, а теги шаблонов с информацией о каких-либо ошибках при отправке формы авторизации уже есть в базовом шаблоне, то в login.html мы зададим наследование от шаблона главной страницы, т.е. {% extends '../octapp/tests_lists.html' %}. Также в settings.py следует добавить строчку «LOGIN_REDIRECT_URL = '/'», чтобы после успешной регистрации осуществлялось перенаправление пользователя на главную страницу сайта, поскольку если этого не сделать, то пользователь будет перенаправляться на страницу профиля пользователя, а создавать ее не планировалось.

    27.6 Для возможности выхода из учетной записи нужно всего лишь добавить к существующим URL-шаблонам шаблон "url(r'^accounts/logout/$', views.logout, name='auth_logout', kwargs={'next_page': '/'}),". При этом необходимо импортировать представления из django.contrib.auth.

    27.7 Необходимо, чтобы при регистрации пользователь ставил отметку о том, что он принимает пользовательское соглашение, а также о том, что прочитал инструкцию пользователя, которую следует показывать на странице регистрации. Также необходимо, чтобы адреса электронной почты проверялись на уникальность. Для этого в django-registration есть формы RegistrationFormTermsOfService и RegistrationFormUniqueEmail. Нужно создать свою форму с именем RegistrationFormTermOfServiceUniqueEmail, наследуясь от одной из них и используя содержимое другой и добавляя новое поле для подтверждения прочтения инструкции пользователя, которое мы назовем «user_manual». Затем нужно сделать так, чтобы при регистрации использовалась созданная форма, а не стандартная форма RegistrationForm. Для этого прямо в oct\urls.py следует создать новый класс-представление на основе представления для регистрации (это RegistrationView, который импортируем из registration.backends.simple.views), а затем назначить созданную в octapp\forms.py форму RegistrationFormTermOfServiceUniqueEmail. В URL-шаблон accounts/register передаем созданный класс как представление. Также следует предварительно добавить registration в INSTALLED_APPS. Стоит заметить, что новую конфигурацию URL — url(r'^accounts/register/$', RegistrationViewTermOfServiceUniqueEmail.as_view(), name='registration_register'), следует добавлять не в конец списка конфигураций, а перед конфигурацией url(r'^accounts/', include('registration.backends.simple.urls')), иначе для выбора отображаемого представления будет использована конфигурация url(r'^register/$', views.RegistrationView.as_view(), name='registration_register') из registration.backends.simple.urls.

    27.8 Стилизуем страницу регистрации, добавив новый файл стилей с именем register.sass. Чтобы при уменьшении ширины экрана HTML-элементы input с типом checkbox переносились на новую строку вместе с текстом в HTML-элементах label, установим для таких элементов label стилевое свойство «display: inline». Полученную в итоге страницу можно увидеть на рисунке ниже (рис. 27.8Страница регистрации нового пользователя).

28. Для реализации возможности загрузки аватарок пользователем можно использовать какое-либо уже готовое приложение для Django (reusable application) из следующих:
https://github.com/grantmcconnaughey/django-avatar
https://github.com/dimka665/django-awesome-avatar
https://github.com/yueyoum/django-upload-avatar
Документация для приложений по второй и третьей ссылкам слишком скудна, а последняя фиксация изменений в репозиториях этих 2 приложений была сделана 4 года назад, что, весьма вероятно, говорит о том, что их разработка приостановлена. Также следует учесть количество коммитов (400, 33, 18) и то, что над приложением по первой ссылке работало/работает 54 участника, в то время как по второй и третьей — 4 и 1 соответственно. Выбор становится очевидным.
    28.1 Активируем виртуальное окружение (?) и устанавливаем django-avatar командой "pip install django-avatar", а затем делаем миграцию БД командой "«ython manage.py migrate».
    28.2 Добавляем в settings.py настройки, приведенные на листинге ниже.

    Листинг 4. Настройки для приложения django-avatar
    AVATAR_CHANGE_TEMPLATE = 'avatar/change.html'
    AVATAR_DELETE_TEMPLATE = 'avatar/delete.html'
    AVATAR_ADD_TEMPLATE = 'avatar/change.html'
    AVATAR_GRAVATAR_DEFAULT = 'wavatar'
    # В байтах, 150КБ
    AVATAR_MAX_SIZE = 153600

    28.3 Добавляем кнопку со ссылкой на удаление аватарок в шаблон их изменения. Также, чтобы на тестовом сервере должным образом работало обращение к аватаркам, т.е. к медиа-файлам, добавим к списку URL-шаблонов сайта элемент static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) [https://docs.djangoproject.com/en/dev/howto/static-files/#serving-other-directories].

    28.4 Создадим 2 новых шаблона в директории templates/avatars: change.html и delete.html. При верстке шаблонов воспользуемся стандартными шаблонами в качестве примеров. Для стилизации страниц создадим соответствующие файлы стилей: change_avatar.sass, delete_avatar.sass. Также выделим стили для миниатюр в отдельный .sass файл, автоматическую компиляцию которого мы деактивируем в koala, поскольку данный файл не подключается к каким-либо шаблонам, а лишь импортируется. Т.е. при его изменении следует компилировать те файлы стилей, в которых выполняется его импорт.

29. Приступим к созданию моделей тестов (Test), тегов (Tag), списка тегов теста (Tags_list_of_test), категорий тестов (Category) и комментариев к тесту (Comment). При проектировании системы, а именно при создании ER-диаграмм, планировалось, что для поля с описанием теста будет использоваться обычный текст, а для вопросов и вариантов ответа на вопрос в качестве их непосредственного содержимого будут использоваться 2 поля: текст и картинка. Однако, позднее возникла идея использовать 1 поле, в котором можно было бы хранить и текст и изображения. В качестве подобных полей можно использовать поле RichTextUploadingField, которое предоставляет Django-приложение CKEditor (django-ckeditor), репозиторий которого расположен по адресу https://github.com/django-ckeditor/django-ckeditor. Пользователь сможет форматировать содержимое вопросов и вариантов ответа, используя в том числе изображения.
    29.1 Установим django-ckeditor. 
        29.1.1 Для этого, в первую очередь, активируем виртуальное окружение из папки проекта (команда "octenv\Scripts\activate" на локальном тестовом сервере Django, т.е. под Windows, команда "source octenv/bin/activate" на веб-сервере, т.е. под UNIX). Затем используем команду "pip install django-ckeditor", чтобы установить данное приложение (рис. 29.1.1Установка django-ckeditor). Далее добавляем ckeditor и ckeditor_uploader в список установленных приложений в файле основных настроек проекта settings.py.
        
        29.1.2 Здесь же добавим новую переменную-путь CKEDITOR_UPLOAD_PATH = 'uploads/', которая указывает путь к директории загрузки медиа-файлов CKEditor’а относительно директории MEDIA_ROOT. Таким образом, изображения, относящиеся к полю формы RichTextUploadingField, будут загружаться в директорию "uploads" внутри директории MEDIA_ROOT, а URL’ы будут создаваться относительно MEDIA_URL (например, /media/uploads/picture.png). Для содержимого комментариев к тесту будем использовать поле RichTextField, которое можно импортировать из ckeditor.fields. Также добавим в настройки проекта строчку CKEDITOR_IMAGE_BACKEND = 'pillow', чтобы для галереи ckeditor’а создавались и использовались миниатюры, поскольку по умолчанию они не создаются, и в качестве предпросмотра используются полноразмерные изображения.

        29.1.3 Добавим 2 новых URL-шаблона: url(r'^ckeditor/upload/', login_required(ckeditor_views.upload), name='ckeditor_upload') и url(r'^ckeditor/browse/', never_cache(login_required(ckeditor_views.browse)), name='ckeditor_browse')
        к существующим URL-шаблонам проекта в файле oct\urls.py. При этом мы импортируем представления из ckeditor_uploader под именем ckeditor_views, а декоратор login_required импортируем из django.contrib.auth.decorators. Это делается с целью использовать данный декоратор, а не staff_member_required, используемый в представлениях данного приложения по умолчанию. 
        29.1.4 При запуске тестового django-сервера, возникла ошибка ImportError: No module named 'ckeditor'. Причину ошибки найти не удалось, но если устанавливать django-ckeditor глобально, то такая ошибка не появляется. Также интересно, что на pythonanywhere подобной ошибки нет, хотя там приложение было установлено локально. Возможно по той причине, что там используется Python версии 3.6, в то время как на локальном компьютере разработчика используется версия 3.5.2.

    29.2 Создадим модели Test, Comment, Category, ResultScale, Tag, TestRate. Модель TestRate необходима для учета оценок, которые пользователи смогут ставить каким-либо тестам, а также для того, чтобы пользователь мог оценить тест лишь единожды. После этого следует создать и выполнить миграции БД, а также зарегистрировать созданные модели для панели администрирования в файле octapp\admin.py, используя для этого функцию admin.site.register(). Листинг admin.py для данного шага разработки приведен ниже.

        Листинг 5. Файл octapp\admin.py
        from django.contrib import admin
        from .models import Test, Comment, Category, ResultScale, Tag, TestRate

        admin.site.register(Test)
        admin.site.register(Comment)
        admin.site.register(Category)
        admin.site.register(ResultScale)
        admin.site.register(Tag)
        admin.site.register(TestRate)
        
    Теперь на панели администрирования можно работать с созданными моделями. Как и планировалось при создании модели комментариев возможность загрузки изображений на сервер с помощью виджета редактора, отображаемого на странице добавления комментария, отсутствует, но можно добавить изображение по ссылке. Следует проверить, чтобы на сервере была установлена версия 5.2.2 (последняя на данный момент) django-приложения ckeditor, поскольку автоматически приложения не обновляются, а на версии 5.2.1, в случае использования Django версии 1.11 (также последняя версия), встречается ошибка при добавлении новых объектов с полями этого приложения. Поэтому, если там все еще 5.2.1, то следует удалить ее и установить новую версию. на листинге ниже приведен программных код созданных моделей.

    Листинг 6. Созданные в файле octapp\models.py модели
    from django.db import models
    from django.utils import timezone
    from ckeditor_uploader.fields import RichTextUploadingField
    from ckeditor.fields import RichTextField

    class Test(models.Model):
        author = models.ForeignKey('auth.User', related_name='tests', on_delete=models.CASCADE, 
                verbose_name="Пользователь, загрузивший тест", null=True, blank=True)
        category = models.ForeignKey('octapp.Category', related_name='tests', on_delete=models.CASCADE, verbose_name="Категория теста", null=True, blank=True)
        result_scale = models.ForeignKey('octapp.ResultScale', related_name='tests', on_delete=models.CASCADE, verbose_name="Оценочная шкала теста")
        # id est test may contain many tags, and tags may be related to different tests
        # tagS name prefered by Django docs
        tags = models.ManyToManyField('octapp.Tag', related_name='tests', verbose_name="Тег или теги теста", blank=True)

        anonymous_loader = models.BooleanField("Анонимный тест. На странице теста не будет указан пользователь, который загрузил тест.", default=False, blank=True)
        name = models.CharField("Наименование теста", max_length=200, blank=False, unique=True)
        description = RichTextUploadingField("Описание теста", default='Описание теста отсутствует...')
        controlling = models.BooleanField("Использование контроля прохождения теста", default=False)
        time_restricting = models.IntegerField("Ограничение времени прохождения теста в минутах", null=True, blank=True)
        rating = models.IntegerField("Рейтинг теста", default=0, editable=False)
        created_date = models.DateTimeField("Дата создания", default=timezone.now, editable=False)
        published_date = models.DateTimeField("Дата публикации", blank=True, null=True, editable=False)
        ready_for_passing = models.BooleanField("Готовность теста для прохождения другими пользователями", default=False, blank=True, editable=False)

        def publish(self):
            self.published_date = timezone.now()
            self.save()

        def unpublish(self):
            self.published_date = None
            self.save()

        def make_ready_for_passing(self):
            self.ready_for_passing = True
            self.save()

        def review_positively(self):
            self.rating += 1
            self.save()

        def review_negatively(self):
            self.rating -= 1
            self.save()

        def __str__(self):
            return self.name

        class Meta:
            ordering = ["name"]        
            verbose_name = "Тест"
            verbose_name_plural = "Тесты"

    class Comment(models.Model):
        test = models.ForeignKey('octapp.Test', related_name='comments', on_delete=models.CASCADE, verbose_name="Тест, к которому относится комментарий")
        author = models.ForeignKey('auth.User', related_name='comments', verbose_name="Пользователь-автор комментария")

        content = RichTextField("Содержимое комментария", blank=False)
        created_date = models.DateTimeField("Дата создания комментария", default=timezone.now)

        def __str__(self):
            return "Комментарий пользователя «" + self.author.username + "» к тесту " + self.test.name

        class Meta:
            ordering = ["created_date"]    
            verbose_name = "Комментарий"
            verbose_name_plural = "Комментарии"

    class Category(models.Model):
        name = models.CharField("Наименование категории", max_length=100, blank=False, unique=True)
        confirmed = models.BooleanField("Категория подтверждена", default=False)

        def confirm(self):
            self.confirmed = True
            self.save()

        def __str__(self):
            return self.name

        class Meta:
            ordering = ["name"]
            verbose_name = "Категория"
            verbose_name_plural = "Категории"
            permissions = (
                ("confirm_category", "Can confirm_category"),
            )

    class ResultScale(models.Model):
        name = models.CharField("Наименование шкалы", max_length=70, blank=False)
        scale_divisions_amount = models.IntegerField("Количество делений оценочной шкалы", default=0)
        
        divisions_layout = models.CharField(
            "Разметка делений шкалы -- процентные доли каждого деления через запятую",
        max_length=20, blank=False, help_text="например, для 2-бальной шкалы (зачтено, незачтено) разметка делений может быть <q>'40,60'</q>")

        def __str__(self):
            return self.name

        class Meta:
            ordering = ["name"]        
            verbose_name = "Оценочная шкала"
            verbose_name_plural = "Оценочные шкалы"

    class Tag(models.Model):
        name = models.CharField("Наименование тега", max_length=40, blank=False, unique=True)

        def __str__(self):
            return self.name

        class Meta:
            ordering = ["name"]
            verbose_name = "Тег"
            verbose_name_plural = "Теги"
            
    class TestRate(models.Model):
        test = models.ForeignKey('octapp.Test',
                related_name='rates',
                on_delete=models.CASCADE,
                verbose_name="Тест, к которому относится данная пользовательская оценка (рейтинг)",
                null=False, blank=False)
        reviewer = models.ForeignKey('auth.User', related_name='rates', 
                verbose_name="Пользователь, к которому относится данная пользовательская оценка (рейтинг)",
                null=False, blank=False)
        like = models.BooleanField("Тест понравился? Если True — +1 к рейтингу, иначе — -1 к рейтингу",
                null=False, blank=False)

        def __str__(self):
            if self.like:
                rate = "+1"
            else:
                rate = "-1"
            return rate + " от пользователя " + self.reviewer.username

        class Meta:
            verbose_name = "Оценка тестов"
            verbose_name_plural = "Оценки тестов"

30. Реализуем функционал добавления и редактирования новых тестов (но пока только лишь тестов, не включая в это понятия вопросы и варианты ответов) наряду с добавлением новых категорий и тегов. Для этого следует создать соответствующие URL-шаблоны, формы, представления и шаблоны. 

    30.1 Начнем с добавления новых URL-шаблонов в octapp\urls.py. Листинг файла после добавления представлен ниже.


    Листинг 7. octapp\urls.py с новыми URL-шаблонами 
    from django.conf.urls import url
    from . import views

    urlpatterns = [
        url(r'^$', views.tests_lists, name='tests_lists'),
        url(r'^test/(?P<pk>\d+)/$', views.test_detail, name='test_detail'),
        url(r'^test/(?P<test_id>\d+)/review/(?P<user_rate>(like)|(dislike))/$', views.review, name='review'),
        url(r'^test/new/$', views.test_new, name='test_new'),
        url(r'^test/(?P<pk>\d+)/edit/$', views.test_edit, name='test_edit'),
        url(r'^user/(?P<pk>\d+)/tests/$', views.user_tests, name='user_tests'),
        url(r'^test/(?P<pk>\d+)/publish/(?P<through_user_tests>(True)|(False))/$', views.test_publish, name='test_publish'),
        url(r'^test/(?P<pk>\d+)/test_unpublish/(?P<through_user_tests>(True)|(False))/$', views.test_unpublish, name='test_unpublish'),
        url(r'^test/(?P<pk>\d+)/make_ready/$', views.test_make_ready_for_passing, name='test_make_ready_for_passing'),
        url(r'^test/(?P<pk>\d+)/remove/(?P<through_user_tests>(True)|(False))/$', views.test_remove, name='test_remove'),
    ]

    30.2 Создадим форму для добавления тестов, которую назовем TestForm. Это будет форма типа ModelForm, связанная с моделью Test посредством содержащегося в ней класса Meta и использующая большинство полей данной модели, за исключением полей author, rating, created_date, published_date, поскольку их заполнение при добавлении теста пользователем не планировалось и не требуется. Они будут заполняться в коде представлений. Добавим для данной формы поле publish_after_adding логического типа, которое будет отображаться при шаблонизации как input с типом checkbox (для этого используем виджет forms.CheckboxInput) и которое необязательно должно быть отмечено для успешной отправки формы (используем ключевой аргумент конструктора поля required=False). Другими дополнительными полями, которые добавляются в форму, стали new_category и new_tags. Листинг файла octapp\forms.py представлен ниже.

    Листинг 8. Файл octapp\forms.py с формами для регистрации и добавления новых тестов
    from django import forms
    from django.contrib.auth import get_user_model
    from django.contrib.auth.forms import UserCreationForm
    from django.core.exceptions import ValidationError
    from django.forms import CheckboxSelectMultiple
    from django.forms import NumberInput
    from django.forms import TextInput
    from .models import Category

    from registration import validators
    from registration.forms import RegistrationFormTermsOfService
    from .models import Test, Comment

    User = get_user_model()

    class RegistrationFormTermOfServiceUniqueEmail(RegistrationFormTermsOfService):
        user_manual = forms.BooleanField(
            widget=forms.CheckboxInput,
            label=(u'Я прочитал(а) инструкцию пользователя'),
            required=True
        )

        def clean_email(self):
            if User.objects.filter(email__iexact=self.cleaned_data['email']):
                raise forms.ValidationError(validators.DUPLICATE_EMAIL)
            return self.cleaned_data['email']

    class TestForm(forms.ModelForm):
        def __init__(self, *args, **kwargs):
            super(TestForm, self).__init__(*args, **kwargs)
            self.fields['category'].queryset = Category.objects.filter(confirmed=True)
        
        new_category = forms.CharField(
            label=(u'Можете указать новую категорию'),
            required=False,
            help_text=(u'Учтите, что новая категория не будет использована, пока не будет подтверждена администратором или модератором'),
            widget=TextInput(attrs={'maxlength': 80, 'title': 'Допускается использовать строчные и заглавные буквы, цифры, дефис и /', 'placeholder': 'Допускается использовать строчные и заглавные буквы, цифры, дефис и /', 'pattern': '[ a-zA-Zа-яёА-ЯЁ0-9 -/]+'}),
            error_messages={'unique': "Такая категория уже существует, выберите ее из предложенных."}
        )

        new_tags = forms.CharField(
            label=(u'Если требуется, укажите через запятую новые теги'),
            required=False,
            widget=TextInput(attrs={'maxlength': 250,
                                    'title': 'Допускается использовать строчные и заглавные буквы, цифры, запятые, дефис и /',
                                    'placeholder': 'Допускается использовать строчные и заглавные буквы, цифры, запятые, дефис и /',
                                    'pattern': '[a-zA-Zа-яёА-ЯЁ0-9 -/,]+'}),
            error_messages={'unique': "Такой тег уже существует, выберите его из предложенных."}
        )
        
        publish_after_adding = forms.BooleanField(
            widget=forms.CheckboxInput,
            label=(u'Опубликовать тест сразу после отправки (загрузки) либо редактирования теста'),
            required=False
        )
        
        class Meta:
            model = Test
            fields = ('category', 'result_scale', 'tags', 'name',
                    'description', 'controlling', 'time_restricting', 'anonymous_loader')
            # Переопределение стандартного виджета, подробнее на https://djbook.ru/rel1.9/topics/forms/modelforms.html#overriding-the-default-fields
            widgets = {
                'tags': CheckboxSelectMultiple,
                'time_restricting': NumberInput(attrs={'min': 1, 'placeholder': 'Не менее 1 минуты'}),
                'name': TextInput(attrs={'maxlength': 200, 'title': 'Первая буква названия будет преобразована в заглавную, остальные — в строчные. Допускается использовать: буквы, цифры, пробелы, запятые, -/«»():;', 'placeholder': 'Допускается использовать: буквы, цифры, пробелы, запятые, -/«»():;', 'pattern': '[a-zA-Zа-яёА-Я0-9 -/,«»();:]*'}),
            }
            error_messages = {
                'name': {
                    'unique': "Тест с таким именем уже присутствует в системе. Пожалуйста, придумайте другое название.",
                }
            }


    30.3 После добавления еще нескольких URL-шаблонов, а также импортирования функции, которая возвращает переменную-словарь, передаваемую в дополнительный контекст стандартного представления django.contrib.auth.views.login, файл oct\urls.py будет выглядеть так, как представлено на листинге ниже. Мы добавляем этот словарь в дополнительный контекст представления login (extra_context) с той целью, чтобы передавать данные, используемые также для главной страницы со списками тестов, стандартному представлению login. Если этого не делать, то никакие тесты на странице accounts/login отображаться не будут. Функция же нужна для того, чтобы она вызывалась при каждом обращении к URL.

    Листинг 9. Файл oct\urls.py
    from django.conf.urls import url, include
    from django.contrib import admin
    from django.contrib.auth import views
    from django.conf import settings
    from django.conf.urls.static import static
    from registration.backends.simple.views import RegistrationView
    from octapp.forms import RegistrationFormTermOfServiceUniqueEmail

    from django.views.decorators.cache import never_cache
    from django.contrib.auth.decorators import login_required
    from ckeditor_uploader import views as ckeditor_views

    from django.utils import timezone
    from octapp.models import Test
    # Эта функция, также используемая для представления главной страницы, 
    # будет передавать данные в контекст (в extra_context) стандартного представления для авторизации
    from octapp.views import get_tests_lists_context

    class RegistrationViewTermOfServiceUniqueEmail(RegistrationView):
        form_class = RegistrationFormTermOfServiceUniqueEmail

    urlpatterns = [
        url(r'^admin/', admin.site.urls),
        url(r'', include('octapp.urls')),
        url(r'^avatar/', include('avatar.urls')),
        url(r'^accounts/logout/$', views.logout, name='auth_logout', kwargs={'next_page': '/'}),
        # Отправляем переменные из представления главной страницы (tests_lists) в дополнительный контекст представления login
        url(r'^accounts/login/$', views.login, {'template_name': 'octapp/tests_lists.html',
        'extra_context': get_tests_lists_context()}, name='auth_login'),
        url(r'^accounts/register/$', RegistrationViewTermOfServiceUniqueEmail.as_view(), name='registration_register'),
        url(r'^accounts/', include('registration.backends.simple.urls')),
        url(r'^accounts/', include('registration.auth_urls')),
        url(r'^ckeditor/upload/', login_required(ckeditor_views.upload), name='ckeditor_upload'),
        url(r'^ckeditor/browse/', never_cache(login_required(ckeditor_views.browse)), name='ckeditor_browse'),
    ] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT) + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    # ! only for developing


    30.4 Далее добавим в файл octapp\views.py 10 новых представлений. Листинг обновленного файла представлен ниже.

    Листинг 10. Файл octapp\views.py после добавления новых представлений, предназначенных для работы с тестами, категориями тестов, тегами и рейтингом тестов.
    from django.shortcuts import render, redirect, get_object_or_404
    from django.utils import timezone
    from django.contrib.auth.decorators import login_required
    from .forms import TestForm
    from .models import Test, Comment, TestRate, Tag, Category
    from django.contrib.auth import get_user_model
    from django.contrib.auth import views as auth_views
    import re

    # Модель пользователя
    User = get_user_model()

    def get_tests_lists_context():
        showing_tests_per_one_column = 14
        showing_tags_and_categories_amount = 58
        showing_tags = Tag.objects.order_by('pk')[:showing_tags_and_categories_amount]
        showing_categories = Category.objects.filter(confirmed=True).order_by('pk')[:showing_tags_and_categories_amount]

        # левый ряд тестов для списка новых тестов, диапазон от 0го до showing_tests_per_one_column - 1
        left_number_of_new_tests_list = Test.objects.filter(published_date__lte=timezone.now()).order_by('-published_date', 'name')[:showing_tests_per_one_column]
        # левый ряд тестов для списка новых тестов
        right_number_of_new_tests_list = Test.objects.filter(published_date__lte=timezone.now()).order_by('-published_date', 'name')[showing_tests_per_one_column:showing_tests_per_one_column*2]
        # левый ряд тестов для списка рейтинговых тестов, диапазон от 0го до showing_tests_per_one_column - 1
        left_number_of_popular_tests = Test.objects.filter(published_date__lte=timezone.now()).order_by('-rating', 'name')[:showing_tests_per_one_column]
        # левый ряд тестов для списка рейтинговых тестов
        right_number_of_popular_tests = Test.objects.filter(published_date__lte=timezone.now()).order_by('-rating', 'name')[showing_tests_per_one_column:showing_tests_per_one_column*2]
        
        all_tags_count = Tag.objects.order_by('pk').count()
        all_published_test_count = Test.objects.filter(published_date__isnull=False).count()
        all_confirmed_categories_count = Category.objects.filter(confirmed=True).count()
        
        if all_tags_count > showing_tags_and_categories_amount:
            show_elision_marks_for_tags = True
        else:
            show_elision_marks_for_tags = None
        if all_confirmed_categories_count > showing_tags_and_categories_amount:
            show_elision_marks_for_categories = True
        else:
            show_elision_marks_for_categories = None
        if all_published_test_count > left_number_of_new_tests_list.count() + right_number_of_new_tests_list.count():
            show_elision_marks_for_tests = True
        else:
            show_elision_marks_for_tests = None

        unconfirmed_categories = Category.objects.filter(confirmed=False)
        count_of_tests_without_category = Test.objects.filter(category=None).count()
        count_of_tests_with_unconf_cat = 0
        for unconf_cat in unconfirmed_categories:
            count_of_tests_with_unconf_cat += unconf_cat.tests.count()
        tests_lists_context = {'left_number_of_new_tests_list': left_number_of_new_tests_list,
                            'right_number_of_new_tests_list': right_number_of_new_tests_list,
                            'left_number_of_popular_tests': left_number_of_popular_tests,
                            'right_number_of_popular_tests': right_number_of_popular_tests,
                            'showing_tags': showing_tags,
                            'showing_categories': showing_categories,
                            'count_of_tests_with_unconf_cat': count_of_tests_with_unconf_cat,
                            'show_elision_marks_for_tags': show_elision_marks_for_tags,
                            'show_elision_marks_for_categories': show_elision_marks_for_categories,
                            'show_elision_marks_for_tests': show_elision_marks_for_tests,
                            'count_of_tests_without_category': count_of_tests_without_category}
        return tests_lists_context

    # Представление главной страницы
    def tests_lists(request):
        return render(request, 'octapp/tests_lists.html', get_tests_lists_context())

    @login_required
    def user_tests(request, pk):
        published_user_tests = Test.objects.filter(author=request.user).order_by('name').filter(published_date__isnull=False)
        unpublished_user_tests = Test.objects.filter(author=request.user).order_by('name').filter(published_date__isnull=True)
        return render(request, 'octapp/user_tests.html', {'unpublished_user_tests': unpublished_user_tests,
                'published_user_tests': published_user_tests})

    @login_required
    def test_new(request):
        if request.method == "POST":
            # Form форма с пользовательскими данными
            form = TestForm(request.POST)
            if form.is_valid():
                # Если использовать form.save(Commit=False), то выбранные пользователем теги к тесту не добавляются!
                # Это происходит потому невозможно создать связи для объекта, который не сохранен в базе данных.
                # Подробнее см. https://djbook.ru/rel1.9/topics/forms/modelforms.html#the-save-method
                test = form.save()
                test.author = request.user
                test.name = test.name.capitalize()
                stripped_category_name = form.cleaned_data['new_category'].strip(' ')
                # Если пользователь выберет какую-либо категорию и, при этом, введет новую, то новая добавляться не будет,
                # а тесту присвоится выбранная им категория
                if form.cleaned_data['new_category'] and not form.cleaned_data['category']:
                    if not Category.objects.filter(name__iexact=stripped_category_name):
                        test.category = Category.objects.create(name=form.cleaned_data['new_category'].capitalize())
                    else:
                        test.category = Category.objects.get(name__iexact=stripped_category_name)
                if form.cleaned_data['new_tags']:
                    pattern = r'[\w/\-\d ]+'
                    new_tags = re.findall(pattern, form.cleaned_data['new_tags'])
                    for item in new_tags:
                        # Если такого тега еще нет в базе
                        if not Tag.objects.filter(name__iexact=item):
                            new_tag_object = Tag.objects.create(name=item)
                            test.tags.add(new_tag_object)
                        # Если такой тег уже есть в базе
                        else:
                            test.tags.add(Tag.objects.get(name__iexact=item))
                if form.cleaned_data['publish_after_adding']:
                    test.published_date = timezone.now()
                test.save()
                return redirect('test_detail', pk=test.pk)
        else:
            # Пустая форма
            form = TestForm()
        return render(request, 'octapp/test_edit.html', {'form': form})

    def test_detail(request, pk):
        test = get_object_or_404(Test, pk=pk)
        if request.user == test.author:
            is_author = True
        else:
            is_author = False
        if not request.user.is_authenticated:
            return render(request, 'octapp/test_detail.html', {'test': test })
        else:
            try:
                rate_of_current_user = TestRate.objects.get(test=test, reviewer=request.user)
                return render(request, 'octapp/test_detail.html', {'test': test, 'is_author': is_author, 'rate_of_current_user': rate_of_current_user })
            # Пользователь еще не ставил оценку данному тесту
            except TestRate.DoesNotExist:
                return render(request, 'octapp/test_detail.html', {'test': test, 'is_author': is_author })

    @login_required
    def test_edit(request, pk):
        test = get_object_or_404(Test, pk=pk)
        if request.method == "POST":
            form = TestForm(request.POST, instance=test)
            if form.is_valid():
                test = form.save()
                return redirect('test_detail', pk=test.pk)
        else:
            form = TestForm(instance=test)
        return render(request, 'octapp/test_edit.html', {'form': form, 'test': test})

    @login_required
    def test_publish(request, pk, through_user_tests):
        test = get_object_or_404(Test, pk=pk)
        test.publish()
        if through_user_tests == 'True':
            return redirect('user_tests', pk=pk)
        else:
            return redirect('test_detail', pk=pk)

    @login_required
    def test_unpublish(request, pk, through_user_tests):
        test = get_object_or_404(Test, pk=pk)
        test.unpublish()
        if through_user_tests == 'True':
            return redirect('user_tests', pk=pk)
        else:
            return redirect('test_detail', pk=pk)

    @login_required
    def test_make_ready_for_passing(request, pk):
        test = get_object_or_404(Test, pk=pk)
        test.make_ready_for_passing()
        return redirect('test_detail', pk=pk)

    @login_required
    def test_remove(request, pk, through_user_tests):
        test = get_object_or_404(Test, pk=pk)
        test.delete()
        if through_user_tests == 'True':
            return redirect('user_tests', pk=pk)
        else:
            return redirect('tests_lists')

    @login_required
    def review(request, test_id, user_rate):
        test = get_object_or_404(Test, pk=test_id)
        user = request.user
        # Устранение возможности голосовать за других пользователей с помощью ввода URL
        if user == request.user:
            if user_rate == "like":
                bool_rate = True
            elif user_rate == "dislike":
                bool_rate = False
            # Пользователь еще не ставил оценку данному тесту
            if not test.rates.filter(reviewer=user):
                # Создаем новый объект модели TestRate для данного пользователя, теста и оценки, а также
                # добавляем его в связанные объекты объекта Test
                test_rate = TestRate(test=test, reviewer=user, like=bool_rate)
                test_rate.save(force_insert=True)
                if user_rate == "like":
                    test.review_positively()
                else:
                    test.review_negatively() 
                return redirect('test_detail', pk=test_id)
            else:
                return redirect('tests_lists')            
        else:
            return redirect('user_tests')

    @login_required
    def comment_remove(request, pk):
        comment = get_object_or_404(Comment, pk=pk)
        test_pk = comment.test.pk
        comment.delete()
        return redirect('test_detail', pk=test_pk)

    Почти все новые представления используют декоратор @login_required, поскольку требуется, чтобы для обращения к данным представлениям требуется, чтобы пользователь был авторизован. Функция get_object_or_404 используется, чтобы в случае отсутствия запрашиваемых объектов выводить пользователю страницу с ошибкой 404. Функция render комбинирует передаваемый ей шаблон с передаваемым ей словарем контекста, а затем возвращает объект HttpResponse с этим «отрендеренным» (другими словами — сгенерированным, полученным в итоге) текстом. Требует некоторого пояснения логика работы представления для добавления новых тестов. В том случае, если HTTP-методом запроса является POST, то выполняется добавление новых данных. В противном случае в шаблон octapp/test_edit.html передается пустая форма, чтобы пользователь ее заполнил и отправил, а это будет уже метод POST. Далее, если форма прошла валидацию, метод save() формы создает и сохраняет в БД новый объект модели Test, используя для этой цели введенные в формы данные. Затем выполняется изменение некоторых данных этого созданного объекта-теста. Если пользователь ввел новую категорию в соответствующее поле формы и не выбрал какую-либо из предложенных полем формы category, то будет создана новая категория с капитализацией введенного пользователем наименования новой категории. При этом выполняется проверка, есть ли уже в БД подобная категория. Для этой цели введеная пользователем строка с именем новой категории обрабатывается строковым Python-методом strip(), чтобы избавиться от возможных пробелов перед и после самого слова либо словосочетания, введенных пользователем случайно либо намеренно, затем осуществляется фильтрация по объектам модели Category, а именно по полю наименования без учета регистра букв, т.е. регистронезависимый поиск. Если в результате фильтрации был возвращен пустой список, то создается новый объект модели Category, который присваивается данному тесту. Если подобная категория уже есть, т.е. был возвращен непустой список, то тесту присваивается эта уже существующая категория.
    Далее учитываются данные, введенные пользователем в поле для новых тегов. Проверяется, если ли уже теги с такими наименованиями в БД. При проверке регистр букв не учитывается. Для этого используется тип django-фильтра __iexact. С помощью метода строк strip выполняется удаление возможных пробелов, символов переноса строки, табуляции, возврата каретки, которые располагаются в начале либо в конце тега из сформированного списка. Если тег уже присутствует, то выполняется добавление нового тега в список связанных с тестом тегов с помощью метода add() менеджера связанных объектов RelatedManager.
    Как выяснилось, СУБД SQLite поддерживает регистронезависимый только по ASCII-символам [https://www.sqlite.org/faq.html#q18]. Т.е. запрос Category.filter(name__iexact='другие') ничего вернет, несмотря на то, что в БД присутствует категория с именем 'Другие'. Это критично для добавления новой категории, поскольку условие, которое определяет отсутствие в БД категории с именем, введенным пользователем в соответствующее поле формы TestForm, не работает так, как ожидается в случае использования кириллицы для имен категорий. В итоге, если пользователь попытается добавить уже существующую категорию, то возникнет ошибка о нарушении ограничения на уникальность значения поля с именем категории. Несмотря на то, что есть способы решить эту проблему, как отмечается в [https://djbook.ru/rel1.9/ref/databases.html#sqlite-string-matching], они не включены в Django и кажутся довольно сложными. В связи с этим решено перейти на другую СУБД, а именно — на PostgreSQL, поскольку в любом случае в дальнейшем можно столкнуться с ограничениями функционала SQLite. Была осуществлена попытка переходна на MySQL, однако, к сожалению, безуспешная, вследствие возникновения ошибки при попытке создания миграций БД о том, что таблицы в БД не существуют. При этом даже удаление старых миграций никак не помогло. Также смущает 5-минутный таймаут неактивности соединения с MySQL на PythonAnywhere, что может стать проблемой либо потребует затрат времени на обход данной проблемы. Поскольку на PythonAnywhere PostgreSQL доступен только для платных аккаунтов, следует перейти на другой хостинг, а именно — Heroku.

    Извлекаем существующие в БД данные с помощью команды «python manage.py dumpdata -e contenttypes -e auth.Permission -e admin -e sessions > fixture.json». В результате работы этой команды получаем файл с данными в формате «.json». 

    Далее устанавливаем для на компьютер разработчика, на котором хранится локальная копия проекта, PostgreSQL, используя инсталлятор, взятый по адресу http://www.enterprisedb.com/products-services-training/pgdownload#windows. Затем создаем БД и пользователя БД. В нашем случае, поскольку ОС — Windows, следует также осуществить несколько шагов:
        Открыть командную строку
        Ввести и отправить команду «setx PATH "%PATH%;C:\Program Files\PostgreSQL\9.6\bin"», чтобы добавить в переменную среды PATH путь к PostgreSQL.
        Закрыть командную строку и открыть ее вновь.
    Здесь в нашем случае возникла небольшая проблема — вышеупомянутая команда добавила новый путь в пользовательскую переменную среды PATH, но этот путь был усечен. Эта проблема была решена добавлением пути C:\Program Files\PostgreSQL\9.6\bin в глобальную системную переменную среды PATH с помощью интерфейса ОС, т.е. через панель управления dashboard.heroku.com/apps) -> система и безопасность -> система -> дополнительные параметры системы -> переменные среды -> системные переменные.
    Далее вводим в командной строке следующие команды:
        psql -U postgres -W
        CREATE USER octuser WITH password 'yadanil12345';
        CREATE DATABASE octdb OWNER oct;
        alter role user_name set client_encoding to 'utf8';
        alter role user_name set default_transaction_isolation to 'read committed';
        alter role user_name set timezone to 'UTC';

    Другие команды для работы с psql, а также их описание можно найти на https://www.postgresql.org/docs/devel/static/app-psql.html.        
    Далее нужно обновить настройки DATABASES в файле oct\settings.py. Листинг новых настроек приведен ниже.

    Листинг 11. Новые настройки DATABASES
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': 'octdb',
            'USER': 'octuser',
            'PASSWORD': 'yadanil12345',
            'HOST': 'localhost',
            'PORT': '',
        }
    }

    Теперь следует установить Heroku Toolbelt из https://devcenter.heroku.com/articles/heroku-cli#download-and-install, который понадобится позднее при развертывании проекта, а также Python интерфейс к PostgreSQL, который именуется «psycopg2». В случае Windows его можно взять отсюда: http://www.stickpeople.com/projects/python/win-psycopg/. Загруженный файл переименовываем в psycorg2 и помещаем в папку проекта. Далее, активировав виртуальное окружение, вводим в терминале команду «easy_install psycorg2.exe».

    Затем удаляем все миграции, относящиеся к прежней БД и находящиеся в папке octapp\migrations, т.е. там оставляем лишь файл __init__.py. Далее пытаемся выполнить миграцию новой БД с помощью команды «python manage.py migrate». Здесь мы видим, что выводятся некоторые ошибки. Просто закомментируем все то, что имеет к ним отношение и упоминается в этих ошибках. Сначала, например, это будет модель Tag. Далее, после успешного выполнения миграций, создаем первоначальные (initial) миграции с помощью команды «python manage.py makemigrations» (рис. 30.4_1Создание и выполнение миграций для новой БД под управлением PostgreSQL). Затем постепенно раскомментируем закоментированные строки, начиная с модели Tag.

    Далее загружаем сохраненные ранее данные из прежней БД с помощью команды «python manage.py loaddata fixture.json» и создаем суперпользователя с помощью команды «python manage.py createsuperuser». Однако возможности сделать это нет, поскольку файл был случайно удален функцией отмены всех изменений Git’а.

    Теперь развернем проект на heroku.com. Нужно создать файл requirements.txt, который будет сообщать Heroku, какие Python-пакеты должны быть установлены на сервере. Но сначала следует установить несколько новых пакетов командой «pip install dj-database-url gunicorn whitenoise». Затем отправить команду «pip freeze > requirements.txt», в результате который сгенерируется файл requirements.txt. 

    Gunicorn — это Python WSGI HTTP сервер для UNIX, а dj-database-url — утилита для использования методологии создания SaaS-приложений «Приложение двенадцати факторов» [https://12factor.net/ru/, https://github.com/kennethreitz/dj-database-url]. Содержимое полученного файла приведено на листинге ниже.

    Листинг 12. Содержимое файла requirements.txt
    astroid==1.5.2
    colorama==0.3.8
    dj-database-url==0.4.2
    Django==1.11
    django-appconf==1.0.2
    django-avatar==3.1.0
    django-ckeditor==5.2.2
    django-registration==2.2
    gunicorn==19.7.1
    isort==4.2.5
    lazy-object-proxy==1.2.2
    mccabe==0.6.1
    olefile==0.44
    Pillow==4.1.0
    psycopg2==2.6.2
    pytz==2017.2
    six==1.10.0
    whitenoise==3.3.0
    wrapt==1.10.10

    Далее создадим файл Procfile, котоырй будет сообщать Heroku, какие выполнять команды, чтобы запустить сайт. В файле будет лишь одна строка — «web: gunicorn oct.wsgi», которая обозначает, что мы собираемся разворачивать веб-приложение с помощью команды «gunicorn oct». Также нужно как-то сообщать Heroku версию Python, которая будет использоваться. Для этого создадим файл runtime.txt, который содержит строку «python-3.5.0» (при переходе на другую СУБД Python несколько раз переустанавливался, поэтому теперь используется версия 3.5.0).
    У Heroku более строгие требования к файлу настроек проекта. А именно, нужно создать локальный файл настроек, который доступен только в локальном виртуальном окружении. Создадим файл local_settings.py. Листинг файла приведен ниже.

    Листинг 13. Содержимое файла oct\local_settings.py
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': 'octdb',
            'USER': 'octuser',
            'PASSWORD': 'yadanil12345',
            'HOST': 'localhost',
            'PORT': '',
        }
    }

    DEBUG = True

    В основном файле настроек заменим «DEBUG = True» на «DEBUG = False», удалим строчку «ALLOWED_HOSTS = ['127.0.0.1', 'customtesting.pythonanywhere.com', '127.0.0.1:8000', 'localhost']» и добавим несколько новых строк, которые приведены на листинге ниже.

    Листинг 14. Новые строки кода для файла oct\settings.py
    import dj_database_url
    DATABASES['default'] = dj_database_url.config()
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

    ALLOWED_HOSTS = ['*']

    # Импортируем файл локальных настроек, если он существует
    try:
        from .local_settings import *
    except ImportError:
        pass

    Далее добавляем в файл oct\wsgi.py пару новых строк:
        from whitenoise.django import DjangoWhiteNoise
        application = DjangoWhiteNoise(application)

    Затем создаем аккаунт на https://id.heroku.com/signup/www-home-top. После регистрации мы видим местную панель управления приложениями (рис. 30.4_3Панель управления dashboard.heroku.com/apps после регистрации). Далее аутентифицируем аккаунт Heroku, используя команду «heroku login». В случае отсутствия SSH-ключа эта команда также должна создать ключ автоматически. Подобные ключи требуется для отправления кода на Heroku, который использует Git для развертывания приложений. В отличие от PythonAnywhere, можно отправлять код на Heroku напрямую, без посредничества Github’а. Cделаем еще несколько манипуляций, а именно, добавим файл local_settings.py в список игнорируемых файлов, который располагается в файле .gitignore, а также удалим содержимое папки media, поскольку там находятся изображения, относящиеся к старой БД. Теперь сохраняем все промежуточные изменения файлов и делаем фиксацию изменений в Git.
    Далее создадим приложение на Heroku с помощью команды «heroku create djangogirlsblog». После ее выполнения наш удаленный репозиторий автоматически был добавлен для нашего приложения. Теперь, чтобы развернуть приложение, нужно воспользоваться командой «git push heroku master», которая отправит файлы локального репозитория на Heroku. Для запуска нашего веб-приложения, используем команду «heroku ps:scale web=1», а команда «heroku open» откроет в браузере вкладку со страницей на наше веб-приложение. Однако, мы видим ошибку Internal Server Error, причина которой заключается в том, что на Heroku для проекта была создана новая пустая БД. Нужно запустить процесс миграции и создать суперпользователя. На этот раз, в отличие от PythonAnywhere, мы можем сделать это из командной строки компьютера разработчика, а не из терминала сервера, используя команды «heroku run python manage.py migrate» и «heroku run python manage.py createsuperuser». Здесь мы сталкиваемся с теми же ошибками, что и ранее при миграции от SQLite на PostgreSQL, поэтому, опять же, воспользуемся тем же приемом закомметирования и раскомметирования кода. Также создадим файл oct\local_urls.py, который добавим в .gitignore и в котором поместим функции для обслуживания статичных файлов и файлов, загружаемых пользователями, т.е. медиа-файлов. Содержимое файла приведено на листинге ниже. В основном же файле oct\urls.py импортируем из данного файла переменную statics и добавляем ее в URL-шаблоны.

    Листинг 15. Файл oct\local_urls.py
    from .settings import STATIC_ROOT, STATIC_URL, MEDIA_ROOT, MEDIA_URL, DEBUG
    from django.conf.urls.static import static

    if DEBUG:
        statics = static(STATIC_URL, document_root=STATIC_ROOT) + static(MEDIA_URL, document_root=MEDIA_ROOT)

    Однако, есть проблема с медиа-файлами на развернутом проекте — они не отображаются. А именно, не отображаются загружаемые аватарки. Причиной этого, как отмечается в [http://whitenoise.evans.io/en/stable/django.html], является то, что утилита для обслуживания статичных файлов WhiteNoise не подходит для работы с загружаемыми пользователями файлами, так называемыми «медиа»-файлами, поскольку не проверяет наличие новых файлов после своего запуска, т.е. добавленные после запуска приложения файлы не будут отображаться. Но даже если бы она проверяла их наличие либо если включить режим отладки в настройках проекта, а к URL-паттернам проекта добавить «static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)» (static — вспомогательная функция, возвращающая URL-шаблон для выдачи, предоставления файлов (статичных либо медиа-файлов) в режиме отладки), то в любом случае архитектура Heroku не позволяет надежно хранить медиа-файлы. Для решения данной проблемы можно воспользователься библиотекой django-storages, которая поддерживает различные варианты хранилищ:  Amazon S3, Azure Storage, DropBox. Как отмечается на [https://stackoverflow.com/questions/36631648/media-files-on-heroku], наилучшим решением проблемы будет использование объектного хранилища «Amazon Simple Storage Service (Amazon S3)». Однако создать аккаунт на данном сервисе не удалось.
    В связи с тем, что другие сервисы предоставляют лишь 30-дневный период бесплатного использования, а также с тем, что могут возникнуть какие-либо другие проблемы на Heroku, решено вернуться на Pythonanywhere и использовать СУБД MySQL, несмотря на то, что там, возможно, придется решать проблему с таймаутом соединения с БД. Даже если не удастся решить эту проблему, то вернемся к SQLite. Другой причиной является отсутствие доступа на Heroku к файлам развернутого проекта, который был на PythonAnywhere, а также необходимость постоянно делать коммиты в Git-репозиторий при небольших изменениях, которые не хотелось бы оформлять в коммит. Приведем локальный проект к состоянию, когда было решено перейти на PostgreSQL и на Heroku, но сохраним при этом файлы oct\local_settings.py и oct\local_urls.py, а в файла oct\settings.py и oct\urls.py оставим строки кода, отвечающие за импортирование тех файлов.


    Воспользуемся инструкциями на [https://help.pythonanywhere.com/pages/UsingMySQL/]. На вкладке «Databases», в разделе MySQL панели управления сайта pythonanywhere.com установим пароль для инициализации MySQL-сервера, который, как там указывается, должен отличаться от пароля пользовательского аккаунта PythonAnywhere (рис. 30.4Страница настроек MySQL сразу после установки пароля). Там же после ввода пароля можно получить данные для соединения, такие как адрес хоста БД и имя пользователя, а также создать новую БД. Создаем базу данных с именем «octdb». Затем, поскольку мы используем виртуальное окружение, следует установить нужную нам Python-библиотеку с помощью команды «pip install mysqlclient» как на PythonAnywhere, так и в виртуальном окружении локальной копии проекта. Пользуемся встроенным в VS Code терминалом. Пакет mysqlclient — это Python-интерфейс к СУБД MySQL.
    Далее следует поменять СУБД в настройках проекта, т.е. в файле oct\settings.py. Удаляем содержимое переменной DATABASES и заменяем его кодом, приведенным на листинге ниже. Для того чтобы запускать Django-тесты на PythonAnywhere, добавляем ключ «TEST» к переменной DATABASES. Далее создаем эту БД с именем test_octdb на вкладке Databases панели управления PythonAnywhere. Создание этой базы обусловлено тем, что при запуске тестов, использующих БД, Django попытается создать БД с именем вида test_<имя первоначальной БД>, а это невозможно, поскольку на PythonAnywhere у Django нет разрешения на создание новой БД.

    Листинг 16. Новое содержимое переменной DATABASES для подключения СУБД MySQL в файле oct\settings.py на PythonAnywhere
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'customtesting$octdb',
            'USER': 'customtesting',
            'PASSWORD': 'ldi87dLdhs65sdkKdgsasoe83',
            'HOST': 'customtesting.mysql.pythonanywhere-services.com',
            'TEST': {
                'NAME': 'customtesting$test_octdb',
            },
            # Активируем строгий режим работы MySQL
            'OPTIONS': {
                'sql_mode': 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE',
            },
        },
    }
    
    Для локальной копии проекта также следует установить MySQL, поскольку, к сожалению, установить соединение локального Django-проекта с БД, созданной на PythonAnywhere, невозможно с бесплатным аккаунтом, как отмечается в источниках [https://stackoverflow.com/questions/33737596/external-access-to-pythonanywhere-mysql-database-with-pandas-and-sqlalchemy, https://www.pythonanywhere.com/forums/topic/3966/]. Для этого загрузим его со страницы https://dev.mysql.com/downloads/installer/ и установим. Далее создадим локальную MySQL БД с помощью MySQL Command Line Client, который при открытии запрашивает пароль, введенный при установке и первоначальном конфигурировании MySQL. Вводим команды для создания БД и отдельного пользователя для Django в MySQL, а также для назначения ему привилегий доступа на все таблицы созданной БД (рис. 30.4_4Использование MySQL Command Line Client). Команды представлены на листинге ниже.
    
    Листинг 17. Команды для создания БД и пользователя, назначения привилегий
    DROP DATABASE IF EXISTS octdb;
    CREATE DATABASE octdb
        DEFAULT CHARACTER SET utf8
        DEFAULT COLLATE utf8_general_ci;
    CREATE USER 'octuser'@'localhost' IDENTIFIED BY 'yadanil12345';
    GRANT ALL PRIVILEGES ON octdb.* TO octuser@localhost IDENTIFIED BY 'yadanil12345';
    FLUSH PRIVILEGES;
    GRANT ALL PRIVILEGES ON test_octdb.* TO octuser@localhost IDENTIFIED BY 'yadanil12345';
    FLUSH PRIVILEGES;

    Здесь команда «FLUSH PRIVILEGES;» обновляет все права доступа. Теперь изменим содержимое переменной DATABASES на локальной версии проекта в файле oct\local_settings.py. Листинг приведен ниже.

    Листинг 18. Новое содержимое переменной DATABASES для подключения СУБД MySQL в файле oct\local_settings.py на локальной копии проекта
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'octdb',
            'USER': 'octuser',
            'PASSWORD': 'yadanil12345',
            'HOST': 'localhost',
            'TEST': {
                'NAME': 'test_octdb',
            },
            # Активируем строгий режим работы MySQL
            'OPTIONS': {
                'sql_mode': 'STRICT_TRANS_TABLES,NO_ZERO_DATE,NO_ZERO_IN_DATE',
            },
        },
    }

    DEBUG = True

    Затем создадим и выполним миграции для новой БД так, как мы это делали при переходе на PostgreSQL, но на этот раз после закомментирования кода будем делать коммиты и отправлять изменения на удаленный репозиторий, чтобы сразу делать миграции для MySQL БД на PythonAnywhere. Затем зададим пути для статичных и медиа-файлов, используя панель управления веб-приложением на PythonAnywhere (рис. 30.4_5Настройка путей для статичных и медиа-файлов). Проверим, что медиа-файлы отображаются, загрузив несколько аватарок (рис. 30.4_6Загруженные аватарки пользователя на развернутом сайте отображаются без ошибок). Далее проверим, что регистронезависимый поиск работает. Для этого создадим с помощью административной панели категорию тестов и оценочную шкалу, а затем добавим тест на соответствующей странице сайта, указывая уже существующую категорию, но с другим регистром букв. К счастью, поиск работает, т.е. используется уже существующая категория. Затем добавим еще несколько новых тегов, категорий, оцночных шкал в БД на PythonAnywhere, а чтобы не добавлять их вручную в локальную БД, извлечем данные из БД на PythonAnywhere с помощью уже знакомых команд «python manage.py dumpdata» и «python manage.py loaddata».

    30.5 Теперь создадим новые шаблоны: test_edit.html, test_detail.html, user_tests.html, а также заменим статичные данные в уже созданном tests_lists.html на контекст шаблона, передаваемого из представления tests_lists. Предполагается, что код созданных шаблонов не требует пояснения, за исключением того, что для адаптивного изменения ширины ckeditor’а в шаблоне test_edit.html используется скрипт, листинг которого приведен ниже. Добиться той же адаптивности с помощью конфигурирования ckeditor’а не удалось, поскольку, несмотря на то, что можно указать ширину виджета редактора в 100%, максимальная ширина ограничивается шириной его панели инструментов.

    Листинг 19. Скрипт для адаптивного изменения ширины виджета редактора ckeditor
    $(document).ready (function() {
        $(".django-ckeditor-widget").css({"width" : "100%"});
    });


    30.6 Создадим шаблоны и соответствующие представления для различных списков тестов, на которые можно перейти из главной страницы. Реализуем также постраничную навигацию на них, ориентируясь на сведения из [https://djbook.ru/rel1.9/topics/pagination.html]. Всего можно выделить 6 списков, на которые возможно будет перейти с главной страницы сайта:
        1. список категорий;
        2. тесты с неподтвержденными категориями;
        3. тесты без категории;
        4. тесты определенной категории;
        5. список тегов;
        6. тесты без тегов
        7. тесты c определенными тегами;
        8. новые тесты;
        9. рейтинговые тесты.
    Их можно объединить в 2 группы по признаку их представления в шаблоне. В первую группу войдут список под номерами 1 и 5, а во вторую группу — все остальные списки. На рисунке ниже представлено, откуда именно можно будет перейти к данным спискам.
    рис. 30.6_7Ссылки на потенциальные списки категорий, тегов и тестов

    Т.е. понадобятся 3 представления, 3 URL-шаблона , 3 HTLM-шаблона. Назовем их tests, tags и categories. (по 1 представлению, URL-шаблону и HTML-шаблону для каждого имени). При этом вынесем фильтрацию, сортировку и постраничную навигацию в отдельные шаблоны list_with_pagination и list_with_filtering_and_pagination, а в файле с представлениями вынесем функции для формирования контекста для постраничной навигации, фильтрации и сортировки в отдельные функции, чтобы не повторять этот код в каждом из новых представлений. Также, при необходимости, будут созданы файлы стилей. Стоит отметить, что при работе над данными шаблонами и представлениями было исправлено отображаемое на главной странице количество тестов с определенными тегами и категориями, присутствующих в системе. Если прежде в это количество входили и опубликованные, и неопубликованные тесты, что неправильно, то теперь в это число входят только опубликованные тесты. Соответственно, функция get_tests_lists_context() и шаблон главной страницы tests_lists.html теперь выглядят немного иначе. Листинг измененной функции не представлен отдельно, поскольку объем работы и так слишком большой, но конечный листинг файла с представлениями octapp\views.py можно найти в соответствующем приложении. Приведем лишь новые функции и представления на листинге ниже.

    Листинг 20. Новые функции и представления в octapp\views.py вместе с измененным представлением списка тестов авторизованного пользователя «user_tests»
    # Получает данные и возвращает контекст, связанный с постраничным выводом
    def get_pagination(page, some_page, on_one_page, max_pages_before_or_after_current):
        paginator = Paginator(some_page, on_one_page)
        try:
            some_page = paginator.page(page)
        except PageNotAnInteger:
            some_page = paginator.page(1)
        except EmptyPage:
            some_page = paginator.page(paginator.num_pages)
        # Все страницы меньше текущей будут отображены
        if page - max_pages_before_or_after_current <= 1:
            # Диапазон номеров страниц, которые меньше текущей
            pages_before_current = range(1, paginator.num_pages if page > paginator.num_pages else page)
            previous = None
        # Не все страницы меньше текущей будут отображены
        else:
            pages_before_current = range(page - max_pages_before_or_after_current, paginator.num_pages if page > paginator.num_pages else page)
            previous = pages_before_current[0] - 1
        # Если правый отображаемый диапазон номеров страниц выходит за границы возможных номеров
        if page + max_pages_before_or_after_current >= paginator.num_pages:
            # Диапазон номеров страниц, которые больше текущей        
            pages_after_current = range(page + 1, paginator.num_pages + 1)
            next = None
        else:
            pages_after_current = range(page + 1, page + max_pages_before_or_after_current + 1)
            next = pages_after_current[-1] + 1
        context = {'pages_before_current': pages_before_current,
                'pages_after_current': pages_after_current,
                'previous': previous,
                'next': next,
                'some_page': some_page}
        return context

    def get_filtered_and_sorted_tests_with_pagination(request, tests):
        q_dict = request.GET.dict()
        context = { }
        if request.GET.get('selected_category', '') == 'null':
            # Отбираем тесты без категории
            tests = tests.filter(category__isnull=True).order_by('name')
            context['selected_category'] = 'null'
        elif request.GET.get('selected_category', '') == 'unconfirmed':
            # Отбираем тесты с неподтвержденной категорией
            tests = tests.filter(category__confirmed=False).order_by('name')
            context['selected_category'] = 'unconfirmed'
        elif request.GET.get('selected_category', '') == 'any':
            context['selected_category'] = 'any'
        elif 'selected_category' in request.GET:
            selected_category_object = get_object_or_404(Category, pk=int(request.GET.get('selected_category')))
            # Отбираем тесты с определенной категорией
            tests = tests.filter(category=selected_category_object)
            context['selected_category'] = request.GET.get('selected_category')
            context['selected_category_object'] = selected_category_object

        if request.GET.get('selected_tag', '') == 'null':
            # Отбираем тесты без тегов
            tests = tests.filter(tags__isnull=True)
            context['selected_tag'] = 'null'
        elif request.GET.get('selected_tag', '') == 'any':
            # Отбираем тесты с любыми тегами
            context['selected_tag'] = 'any'
        elif 'selected_tag' in request.GET:
            selected_tag_object = get_object_or_404(Tag, pk=int(request.GET.get('selected_tag')))
            # Отбираем тесты с определенным тегом
            tests = tests.filter(tags=selected_tag_object)
            context['selected_tag'] = request.GET.get('selected_tag')
            context['selected_tag_object'] = selected_tag_object

        if request.GET.get('sorting', '') == 'rating_desc':
            tests = tests.order_by('-rating', 'name')
            context['sorting'] = 'rating_desc'
        elif request.GET.get('sorting', '') == 'published_date_desc':
            tests = tests.order_by('-published_date')
            context['sorting'] = 'published_date_desc'
        elif request.GET.get('sorting', '') == 'name_asc':
            tests = tests.order_by('name')
            context['sorting'] = 'name_asc'

        if request.GET.get('filter_ready_for_passing', '') == 'on':
            tests = tests.filter(ready_for_passing=True)
            context['filter_ready_for_passing'] = 'on'
        elif request.GET.get('filter_time_restriction', '') == 'on':
            tests = tests.filter(time_restricting__isnull=False)
            context['filter_time_restriction'] = 'on'
        elif request.GET.get('filter_passing_control', '') == 'on':
            tests = tests.filter(controlling=True)
            context['filter_passing_control'] = 'on'

        # По-хорошему, в случае использования функции для представления tests,
        # этот код не нужен. Он используется только для представления user_tests
        if request.GET.get('publish_status', '') == 'published':
            tests = tests.filter(published_date__lte=timezone.now())
            context['publish_status'] = 'published'
        elif request.GET.get('publish_status', '') == 'unpublished':
            tests = tests.filter(published_date__isnull=True)
            context['publish_status'] = 'unpublished'
        elif request.GET.get('publish_status', '') == 'any':
            context['publish_status'] = 'any'
        # Если этого HTTP-параметра вообще нет в запросе,
        # то в tests все еще будут как опубликованные, так и неопубликованные тесты 

        page = request.GET.get('page', '1')
        page = int(page)
        # 35, 5 prod
        pag_context = get_pagination(page, tests, 35, 5)
        context.update(pag_context)

        categories_for_filtering_of_tests = Category.objects.filter(confirmed=True).order_by('name')
        tags_for_filtering_of_tests = Tag.objects.order_by('name')
        context.update({'categories_for_filtering_of_tests': categories_for_filtering_of_tests, 'tags_for_filtering_of_tests': tags_for_filtering_of_tests})

        q = QueryDict(mutable=True)
        # В навигационных ссылках добавляется &page=X, поэтому если в запросе уже есть page, 
        # добавленный после перехода по страницам, то нужно его удалить
        if 'page' in q_dict:
            q_dict.pop('page')
        q.update(q_dict)
        context['HTTPparameters'] = '?' + q.urlencode()
        return context

    def get_categories_with_count_of_published_tests(context, categories):
        # Нужно изменить количество тестов, выводимых при фильтрации по категории
        categories_and_count_of_published_tests_in_them = []
        for category in categories:
            categories_and_count_of_published_tests_in_them.append([category, category.tests.filter(published_date__lte=timezone.now()).count])
        context['categories_and_count_of_published_tests_in_them'] = categories_and_count_of_published_tests_in_them
        return context

    def get_tags_with_count_of_published_tests(context, tags):
        # Нужно изменить количество тестов, выводимых при фильтрации по тегу
        tags_and_count_of_published_tests_in_them = []
        for tag in tags:
            tags_and_count_of_published_tests_in_them.append([tag, tag.tests.filter(published_date__lte=timezone.now()).count])
        context['tags_and_count_of_published_tests_in_them'] = tags_and_count_of_published_tests_in_them
        return context

    # 3 списка тестов (№ 2, № 3, № 4), на которые можно перейти из главной страницы
    def tests(request):
        # Если сортировка не задана, то тесты будут по алфавиту
        tests = Test.objects.filter(published_date__lte=timezone.now()).order_by('name')
        context = get_filtered_and_sorted_tests_with_pagination(request, tests)
        context = get_categories_with_count_of_published_tests(context, context['categories_for_filtering_of_tests'])
        context = get_tags_with_count_of_published_tests(context, context['tags_for_filtering_of_tests'])
        return render(request, 'octapp/tests.html', context)

    def categories(request):
        categories = Category.objects.filter(confirmed=True).order_by('name')
        context = get_pagination(int(request.GET.get('page', '1')), categories, 45, 5)
        context = get_categories_with_count_of_published_tests(context, categories)
        return render(request, 'octapp/categories.html', context)

    def tags(request):
        tags = Tag.objects.order_by('name')
        context = get_pagination(int(request.GET.get('page', '1')), tags, 45, 5)
        context.update(get_tags_with_count_of_published_tests(context, tags))
        return render(request, 'octapp/tags.html', context)

    @login_required
    def user_tests(request, pk):
        user_tests = Test.objects.filter(author=request.user).order_by('name')
        context = get_filtered_and_sorted_tests_with_pagination(request, user_tests)
        # Нужно изменить количество тестов, выводимых при фильтрации по категории или по тегу
        categories_and_count_of_user_tests_in_them = []
        tags_and_count_of_user_tests_in_them = []
        for category in context['categories_for_filtering_of_tests']:
            categories_and_count_of_user_tests_in_them.append([category, category.tests.filter(author=request.user).count()])
        for tag in context['tags_for_filtering_of_tests']:
            tags_and_count_of_user_tests_in_them.append([tag, tag.tests.filter(author=request.user).count()])
        context['categories_and_count_of_user_tests_in_them'] = categories_and_count_of_user_tests_in_them
        context['tags_and_count_of_user_tests_in_them'] = tags_and_count_of_user_tests_in_them
        return render(request, 'octapp/user_tests.html', context)

    Представление для списка тестов пользователя user_tests также было изменено, поскольку на страницу тестов авторизованного пользователя решено добавить постраничную навигацию, фильтрацию и сортировку. При этом конкретно для такого списка тестов была добавлена возможность фильтрации списка тестов по статусу публикации. Повторяемость кода сведена к минимуму, благодаря наследованию шаблонов и вынесению кода представлений в отдельные функции в octapp\views.py.

    30.7 «Оживим» статистические данные, отображаемые в подвале. Для этой цели воспользуемся RequestContext и контекстным процессором с данными для статистики в подвале. Создадим файл octapp\context_processors.py, в котором определим функцию, которая принимает объект HttpRequest и возвращает словарь с данными об общем количестве тестов, тегов и категорий в системе, который будет добавляться в контекст всех шаблонов. После чего следует указать созданный контекстный процессор в опции TEMPLATES:OPTIONS:context_processors файла настроек проекта.
    На данном этапе для нашего приложения octapp было создано несколько автоматизированных тестов в файле octapp\tests.py для представления главной страницы и представления определенного теста. Автоматизированные тесты будут дополняться перед реализацией какого-либо функционала и будут подробнее описаны в последнем разделе работы.
    На рисунках ниже можно увидеть внешний вид тех страниц, работу над которыми можно считать завершенной.
    Рисунки: 30.7_1Главная страница 30.7_2Список тестов пользователя 30.7_3Список тестов 30.7_4Страница добавления нового теста 30.7_5Список категорий 30.7_6Список тегов

    31. Реализуем возможность добавления вопросов и вариантов ответа к ними. Начнем с написания моделей.
    31.1 Создадим модели:
    1. ClosedQuestion — модель вопроса закрытого типа с одним либо несколькими правильными вариантами ответа;
    2. ClosedQuestionOption — модель варианта ответа на определенный вопрос.
    3. OpenQuestion — модель вопроса открытого типа;
    4. SequenceQuestion — модель вопроса на определение последовательности;
    5. ComparisonQuestion — модель вопроса на сопоставление двух рядов элементов сопоставления.
    6. ComparisonQuestionElement — модель элемента левого или правого ряда сопоставления для вопроса на сопоставление.
    7. SequenceQuestionElement — модель элемента для вопроса на определение последовательности.
    8. QuestionOfTest — промежуточная между вопросом и тестом модель списка вопросов определенного теста.
    Модель QuestionOfTest позволит: без труда получать список вопросов теста в одном QuerySet’е, включать в элемент данного списка вопрос любого типа, легко сортировать полученный список вопросов теста с помощью метода order_by QuerySet’а, вынести повторяющееся в моделях вопросов разных типов порядковые номера вопросов в одно поле модели QuestionOfTest.
    31.2 Далее создадим URL-шаблон, HTML-шаблон и представление для отображения вопросов теста, которые назовем questions_of_test. Создадим также автоматизированный тест перед созданием представления и формы ClosedQuestion, OpenQuestion, SequenceQuestion, ComparisonQuestion типа ModelForm для добавления к тесту новых вопросов.
    31.1 Теперь создадим новый URL-шаблон для добавления новых вопросов — «new_question», который выглядит так: url(r'^test/(?P<test_id>\d+)/new_question/(?P<type>(closed)|(open)|(sequence)|(comparison))/$', views.new_question, name='new_question'), а также одноименное представление. Доработаем шаблон со списком тестов, чтобы он отображал также варианты ответа, либо элементы вопроса-последовательности, либо элементы двух рядов (столбцов) сопоставления для вопросов на сопоставление.
    31.2 Реализуем возможность удаления и редактирования добавленных вопросов. Для этой цели мы создадим двумерный список, который будем заполнять парами [вопрос теста, заполненная текущими данными вопроса форма]. Эти формы будем выводить рядом с каждым вопросом, но отображать только при нажатии на кнопку для редактирования вопроса, отображаемую также рядом с каждым вопросом. Представление для редактирования вопроса должно соответствующим образом менять порядковые номера вопросов при их изменении, а представление для удаления — уменьшать на 1 порядковый номер у всех вопросов, следующих после удаленного.


    31.3 Далее реализуем функционал добавления вариантов ответа на вопрос / элементов вопроса-последовательности / элементов сопоставления для вопроса на сопоставление. Для этой цели понадобится новый URL-шаблон — url(r'^test/(?P<test_id>\d+)/question/(?P<question_of_test_id>\d+)/new_option/$', views.new_option, name='new_option'), новое одноименное представление и добавление в шаблон questions_of_test.html новых форм и кнопок.
	

ДАЛЕЕ ВЕДЕНИЕ ЭТОГО "ДНЕВНИКА" БЫЛО ПРЕКРАЩЕНО ИЗ-ЗА НЕХВАТКИ ВРЕМЕНИ
	
	
	
НЕРЕАЛИЗОВАННЫЙ И МЕНЕЕ ВАЖНЫЙ ФУНКЦИОНАЛ

x. Модерирование
    x.x подтверждение и удаление категорий
    x.x удаление тестов
    x.x изменение группы доступа пользователей
    x.x удаление тегов
    x.x возможность для суперпользователя видеть неопубликованные тесты пользователей (!необязательный функционал)

x. Функционал назначения модераторов
https://djbook.ru/rel1.9/topics/auth/default.html#topic-authorization
myuser.groups.add(group, group, ...)
myuser.groups.remove(group, group, ...)
myuser.groups.clear()

x. авторизация и регистрация с помощью данных из соц. сетей
https://habrahabr.ru/sandbox/48565/
